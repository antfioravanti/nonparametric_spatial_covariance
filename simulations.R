# MASTERARBEIT DARWIN 
#-------------------------------------------------------------------------------
if (!require(MASS)) install.packages("MASS"); library(MASS)
if (!require(ggplot2)) install.packages("ggplot2"); library(ggplot2)
if (!require(foreach)) install.packages("foreach"); library(foreach)
if (!require(doParallel)) install.packages("doParallel"); library(doParallel)
if (!require(tictoc)) install.packages("tictoc"); library(tictoc)
if (!require(reshape2)) install.packages("reshape2"); library(reshape2)
if (!require(pheatmap)) install.packages("pheatmap"); library(pheatmap)
setwd(file.path(dirname(rstudioapi::getActiveDocumentContext()$path)))
source("utils_functions.R") # Upload functions in separate script
set.seed(1234)# set seed for replication
#-------------------------------------------------------------------------------
# SIMULATION OF GRID

xdim = 30 # horizontal size
ydim = 30 #vertical size

# Erzeugt zufällige Koordinaten im Bereich [0, 1] für das Raster
grid = data.frame(x = runif(xdim, 0, 1), y = runif(ydim, 0, 1))

# Selecting Points with many neighbours and few neighbours
point_many = select_point_by_neighbour(grid, choice = "many", perc = 0.1)
point_few = select_point_by_neighbour(grid, choice = "few", perc = 0.1)
index_many = point_many$index
index_few = point_few$index
#-------------------------------------------------------------------------------
# plot(grid$x, grid$y,
#      main = "Spatial Locations Generated by Random Uniform Distribution",
#      xlab = "x-coordinate", ylab = "y-coordinate",
#      pch = 16, col = "blue")
# text(grid$x, grid$y, labels = 1:nrow(grid), pos = 3, cex = 0.7, col = "red")
#-------------------------------------------------------------------------------
# GENERATE TRUE ANALYTICAL COVARIANCE
#-------------------------------------------------------------------------------

sigma = 1
phi = 3
true_covariance = cov_exponential(grid, sigma, phi, method = "difference")

# phi_values = c(0.1, 0.5, 1, 2)
# sigma = 1  
# visualize_covariance(grid, sigma, phi_values, method = "euclidean")

#sigma = 1
#alpha1 = 1
#alpha2 = 1
#lambda1 = 5
#lambda2 = 5
#true_covariance = ModifiedExponentialCovariance(grid,sigma,alpha1,alpha2,lambda1
                                                #,lambda2,test_sep =T)$covariance

#plot_matrix(grid, sigma = 1, phi = 5)
#plot_matrix_modi(grid,sigma,alpha1,alpha2,lambda1, lambda2, test_sep = FALSE)


#-------------------------------------------------------------------------------

#Check covariance is positive semidefinite
is_positive_semi_definite(true_covariance)

#-------------------------------------------------------------------------------
# SIMULATE SPATIAL GAUSSIAN RANDOM FIELD
X = mvrnorm(n = 1, mu = rep(0, nrow(grid)), Sigma = true_covariance)
grid$sim = X

#Plot the process where the colors indicate the value of the spatial process
ggplot(grid, aes(x = x, y = y, color = sim)) +
  geom_point(size = 5) +
  scale_color_gradient(low = "blue", high = "red") +
  labs(title = "Simulated Spatial Data", x = "X Coordinate", y = "Y Coordinate",
       color = "Value") +
  theme_minimal()

# Add a 'type' variable to indicate point categories
grid$type <- "Normal"
grid$type[index_many] <- "Many"
grid$type[index_few] <- "Few"

# Define custom shapes for each type
shape_values <- c("Normal" = 16, "Many" = 17, "Few" = 15)

# Create the plot
ggplot(grid, aes(x = x, y = y, color = sim, shape = type)) +
  geom_point(size = 5) +
  scale_color_gradient(low = "blue", high = "red") +
  scale_shape_manual(values = shape_values) +
  labs(title = "Simulated Spatial Data",
       x = "X Coordinate",
       y = "Y Coordinate",
       color = "Value",
       shape = "Point Type") +
  theme_minimal()



#-------------------------------------------------------------------------------
# ESTIMATE SPATIAL COVARIANCE

bandwidth = 0.1 # Beispiel-Bandbreite

#kernel = "gaussian_kernel"

#kernel = "epanechnikov_kernel"

kernel = "rechteck_kernel"

#kernel = "triangle_kernel"

#kernel = "cubic_b_spline_kernel"

#-------------------------------------------------------------------------------

tic("matrix cov estimation")
est_cov_matrix = matrix(NA, nrow = nrow(grid), ncol = nrow(grid))
for(i in 1:nrow(grid)) {
  for(j in 1:nrow(grid)) {
    est_cov_matrix[i,j] = kernel_cov(as.numeric(grid[i, 1:2]),
                                     as.numeric(grid[j, 1:2]),
                                     X, grid[,1:2],
                                     bandwidth, kernel)$covariance
  }
}
toc()

is_positive_semi_definite(est_cov_matrix)


# Prüfen für nur ein Punktpaar auf dem Gitter

result <- kernel_cov(as.numeric(grid[1, 1:2]),
           as.numeric(grid[2, 1:2]),
           X, grid[,1:2],
           bandwidth, kernel)

View(result$weights)



# tic(" auto matrix cov estimation") # Berechne die Autokorrelationsmatrix
# est_corr_matrix = matrix(NA, nrow = nrow(grid), ncol = nrow(grid))
# for(i in 1:nrow(grid)) {
#   for(j in 1:nrow(grid)) {
#     est_corr_matrix[i,j] = est_cov_matrix[i,j] /
#       sqrt(est_cov_matrix[i,i] * est_cov_matrix[j,j])
#   }
# }
# toc()
# 
# 
# # Prüfen, ob die Diagonalelemente 1 sind
# diag(est_corr_matrix)
# is_positive_semi_definite(est_corr_matrix)


#-------------------------------------------------------------------------------
# Norm 12.17411
norm(est_cov_matrix - true_covariance, type = "2")

#-------------------------------------------------------------------------------
# Norm with autokorellation
norm(est_corr_matrix - true_covariance, type = "2")


tic("matrix cov estimation")
est_cov_matrix_flo = matrix(NA, nrow = nrow(grid), ncol = nrow(grid))
for(i in 1:nrow(grid)) {
  for(j in 1:nrow(grid)) {
    est_cov_matrix_flo[i,j] = kernel_cov_flo(as.numeric(grid[i, 1:2]),
                                     as.numeric(grid[j, 1:2]),
                                     X, grid[,1:2],
                                     bandwidth, kernel)$covariance
  }
}
toc()


is_positive_semi_definite(est_cov_matrix_flo)

norm(est_cov_matrix_flo - true_covariance, type = "2")

#-------------------------------------------------------------------------------

# Differenzmatrix berechnen
diff_matrix <- est_cov_matrix - true_covariance

# Heatmap der Differenzmatrix erstellen
pheatmap(diff_matrix, 
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         color = colorRampPalette(c("blue", "white", "red"))(50),
         main = "Heatmap der Differenz")


#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
