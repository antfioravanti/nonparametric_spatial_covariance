# MASTERARBEIT DARWIN
#-------------------------------------------------------------------------------
if (!require(MASS)) install.packages("MASS"); library(MASS)
if (!require(ggplot2)) install.packages("ggplot2"); library(ggplot2)
if (!require(foreach)) install.packages("foreach"); library(foreach)
if (!require(doParallel)) install.packages("doParallel"); library(doParallel)
if (!require(tictoc)) install.packages("tictoc"); library(tictoc)
setwd(file.path(dirname(rstudioapi::getActiveDocumentContext()$path)))
source("utils_functions.R") # Upload functions in separate script
set.seed(1234)# set seed for replication
#-------------------------------------------------------------------------------
# SIMULATION OF GRID

xdim = 30 # horizontal size
ydim = 30 #vertical size

# Erzeugt zufällige Koordinaten im Bereich [0, 1] für das Raster
grid = data.frame(x = runif(xdim, 0, 40), y = runif(ydim, 0, 40))
#-------------------------------------------------------------------------------
plot(grid$x, grid$y, 
     main = "Spatial Locations Generated by Random Uniform Distribution",
     xlab = "x-coordinate", ylab = "y-coordinate",
     pch = 16, col = "blue")
text(grid$x, grid$y, labels = 1:nrow(grid), pos = 3, cex = 0.7, col = "red")
#-------------------------------------------------------------------------------
# GENERATE TRUE ANALYTICAL COVARIANCE
#-------------------------------------------------------------------------------

sigma = 1
phi = 4
true_covariance = cov_exponential(grid, sigma, phi, method = "difference")

#-------------------------------------------------------------------------------
#sigma = 1
#a = 0.1
#c = 0.5
#beta = 0
#true_covariance_gn <- cov_gneiting(grid,sigma, a, c,beta,method = "difference")

#-------------------------------------------------------------------------------

#Check covariance is positive semidefinite
is_positive_semi_definite(true_covariance)

#-------------------------------------------------------------------------------
# SIMULATE SPATIAL GAUSSIAN RANDOM FIELD
X = mvrnorm(n = 1, mu = rep(0, nrow(grid)), Sigma = true_covariance)
grid$sim = X

#Plot the process where the colors indicate the value of the spatial process
ggplot(grid, aes(x = x, y = y, color = sim)) +
  geom_point(size = 5) +
  scale_color_gradient(low = "blue", high = "red") +
  labs(title = "Simulated Spatial Data", x = "X Coordinate", y = "Y Coordinate",
       color = "Value") +
  theme_minimal()

#-------------------------------------------------------------------------------
# ESTIMATE SPATIAL COVARIANCE

bandwidth = 0.21 # Beispiel-Bandbreite

#kernel = "gaussian_kernel"
kernel = "epanechnikov_kernel"
#kernel = "rechteck_kernel"
#kernel = "triangle_kernel"

tic("matrix cov estimation")
est_cov_matrix = matrix(NA, nrow = nrow(grid), ncol = nrow(grid))
est_corr_matrix = matrix(NA, nrow = nrow(grid), ncol = nrow(grid))

for(i in 1:nrow(grid)) {
  for(j in 1:nrow(grid)) {
    est_cov_matrix[i,j] = kernel_cov(as.numeric(grid[i, 1:2]),
                                     as.numeric(grid[j, 1:2]),
                                     X, grid[,1:2],
                                     bandwidth, kernel)$covariance
  }
}
toc()
is_positive_semi_definite(est_cov_matrix)

tic(" auto matrix cov estimation")
# Berechne die Autokorrelationsmatrix
for(i in 1:nrow(grid)) {
  for(j in 1:nrow(grid)) {
    est_corr_matrix[i,j] = est_cov_matrix[i,j] / 
      sqrt(est_cov_matrix[i,i] * est_cov_matrix[j,j])
  }
}
toc()


# Prüfen, ob die Diagonalelemente 1 sind
diag(est_corr_matrix)
is_positive_semi_definite(est_corr_matrix)

# Überprüfen, ob die Matrix symmetrisch ist
is_symmetric <- all(est_cov_matrix == t(est_cov_matrix))
is_symmetric
is_symmetric_corr <- all(est_corr_matrix == t(est_corr_matrix))
is_symmetric_corr

#-------------------------------------------------------------------------------
# Kernel_cov_flo is the covariance without vertorisierung
tic("matrix cov flo estimation")
est_cov_matrix_flo = matrix(NA, nrow = nrow(grid), ncol=nrow(grid))
est_corr_matrix_flo = matrix(NA, nrow = nrow(grid), ncol = nrow(grid))

for(i in 1:nrow(grid)){
  for(j in 1:nrow(grid)){
    est_cov_matrix_flo[i,j] = kernel_cov_flo(as.numeric(grid[i, 1:2]),
                                     as.numeric(grid[j, 1:2]),
                                     X, grid[,1:2],
                                     bandwidth, kernel)$covariance
    
  }
}
toc()

tic(" auto matrix cov flo estimation")
# Berechne die Autokorrelationsmatrix
for(i in 1:nrow(grid)) {
  for(j in 1:nrow(grid)) {
    est_corr_matrix_flo[i,j] = est_cov_matrix_flo[i,j] / 
      sqrt(est_cov_matrix_flo[i,i] * est_cov_matrix_flo[j,j])
  }
}
toc()

# Prüfen, ob die Diagonalelemente 1 sind
diag(est_corr_matrix_flo)
is_positive_semi_definite(est_corr_matrix_flo)

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------

#Check estimated covariance is positive semidefinite
is_positive_semi_definite(est_cov_matrix)
is_positive_semi_definite(est_cov_matrix_flo)

#-------------------------------------------------------------------------------
# Norm 12.17411
norm(est_cov_matrix - true_covariance, type = "2")

#norm(est_cov_matrix_flo - true_covariance, type = "2")

#-------------------------------------------------------------------------------
# Norm with autokorellation
norm(est_corr_matrix - true_covariance, type = "2")

#norm(est_corr_matrix_flo - true_covariance, type = "2")

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# Try to make the matrix positiv with fourier transformation

# Benötigte Bibliotheken
library(pracma) # Für FFT (Fast Fourier Transform)

# 2. Fourier-Transformation auf jede Zeile anwenden
fft_rows <- t(apply(est_cov_matrix_flo, 1, fft))

# 3. Truncation: Setzen Sie alle negativen Frequenzkomponenten auf Null
fft_rows[Re(fft_rows) < 0] <- 0

# 4. Inverse Fourier-Transformation auf jede Zeile anwenden
ifft_rows <- t(apply(fft_rows, 1, function(x) Re(ifft(x))))

# 5. Fourier-Transformation auf jede Spalte anwenden
fft_cols <- apply(ifft_rows, 2, fft)

# 6. Truncation: Setzen Sie alle negativen Frequenzkomponenten auf Null
fft_cols[Re(fft_cols) < 0] <- 0

# 7. Inverse Fourier-Transformation auf jede Spalte anwenden
corrected_cov_matrix <- apply(fft_cols, 2, function(x) Re(ifft(x)))

# 8. Sicherstellen, dass die Matrix symmetrisch ist
corrected_cov_matrix <- (corrected_cov_matrix + t(corrected_cov_matrix)) / 2

# Setzen Sie eventuell sehr kleine negative Eigenwerte auf 0, um die PSD zu garantieren
eigen_values <- eigen(corrected_cov_matrix)$values
if (any(eigen_values < 0)) {
  eig_decomp <- eigen(corrected_cov_matrix)
  eig_values_corrected <- pmax(eig_decomp$values, 0)
  corrected_cov_matrix <- eig_decomp$vectors %*% diag(eig_values_corrected)
  %*% t(eig_decomp$vectors)
}

is_positive_semi_definite(corrected_cov_matrix)
#-------------------------------------------------------------------------------
# try to find the next positiv corelation matrix 
# Installieren und Laden des Matrix-Pakets, falls noch nicht geschehen
if (!require(Matrix)) install.packages("Matrix", dependencies=TRUE)
library(Matrix)

# Berechnung der nächstliegenden PSD-Matrix
near_psd_matrix <- nearPD(est_corr_matrix)$mat

# Überprüfung, ob die Matrix jetzt PSD ist
is_positive_semi_definite <- function(mat) {
  eigen_values <- eigen(mat, symmetric = TRUE, only.values = TRUE)$values
  all(eigen_values >= 0)
}

# Testen, ob die korrigierte Matrix jetzt positiv semi-definit ist
is_positive_semi_definite(near_psd_matrix)

norm(near_psd_matrix - true_covariance, type = "2")

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# try to make test with two point
# Test mit 2 belibiege Punkte
t1 <- c(0.1, 0.3)
t2 <- c(0.09, 0.29)

# Schätze die Kovarianz zwischen t1 und t2
#cov_estimate_eucli <- kernel_cov_euclidean(t1, t2, X,
                                           #grid[,1:2], bandwidth, kernel)

cov_estimate_diff <- kernel_cov(t1, t2, X, grid[,1:2], bandwidth, kernel)

# Gib das Ergebnis aus

#print(cov_estimate_eucli$covariance)

print(cov_estimate_diff$covariance)


#distance <- sqrt(sum((t1 - t2)^2))

#true_covariance_value_eucli <- sigma^2 * exp(-distance / phi)
#print(true_covariance_value_eucli)

dist_x <- abs(t1[1] - t2[1])
dist_y <- abs(t1[2] - t2[2])


true_covariance_value_diff <- sigma^2 * exp(-dist_x / phi) * exp(-dist_y / phi)
print(true_covariance_value_diff)

#-------------------------------------------------------------------------------
# SIMULATION from the Paper

set.seed(1234)
tdim = 200
grid = data.frame(t = runif(tdim, 0, 40))

exp_cov = function(grid){
  return(exp(-as.matrix(dist(grid, method = "euclidean")) * 1.98))
}
true_cov_paper = exp_cov(grid)
# Calculate the pairwise distances
pairwise_distances <- as.matrix(dist(grid, method = "euclidean"))

# Extract unique distances and corresponding covariances
unique_distances <- pairwise_distances[lower.tri(pairwise_distances)]
unique_covariances <- true_cov_paper[lower.tri(true_cov_paper)]

# Create the plot
plot(unique_distances, unique_covariances, 
     xlab = "Distance", 
     ylab = "Covariance", 
     main = "Covariance vs Distance",
     pch = 19, col = "blue")

is_positive_semi_definite(true_cov_paper)

plot_matrix(exp_cov(grid), labels = F)

Xpaper =  mvrnorm(n = 1, mu = rep(0, nrow(grid)), Sigma = true_cov_paper)
bandwidth = 0.4

kernel_cov_1d = function(t1, t2, X, grid, bandwidth,
                      kernel_function="gaussian_kernel"){
  # COMPUTES THE COVARIANCE ESTIMATOR
  
  # Ensure the kernel_function is correctly specified
  kernel_fun = switch(
    kernel_function,
    gaussian_kernel = gaussian_kernel,
    epanechnikov_kernel = epanechnikov_kernel,
    rechteck_kernel = rechteck_kernel,
    triangle_kernel = triangle_kernel,
    stop("Specify either gaussian_kernel or epanechnikov_kernel
         or rechteck_kernel or or triangle_kernel kernel")
  )
  
  Xbar = mean(X) # Sample mean of the simulated values X
  demeaned_X = X - Xbar # X- Xbar
  
  # Lags between the two points
  lag = t1 - t2
  
  # Berechnet die Differenzen zwischen allen x-Koordinaten der Punkte im Raster
  diff_t = outer(grid$t, grid$t, "-")

  
  # Apply the chosen kernel
  k_t = kernel_fun(lag - diff_t, bandwidth)

  X_ij = outer(demeaned_X, demeaned_X, "*") 
  
  #weight = weight_function(t1,t2)
  
  # Numerator
  numerator = sum(k_t * X_ij)
  # Denominator
  denominator = sum(k_t)
  
  # Verhindert eine Division durch Null, falls der Nenner Null ist
  if (denominator == 0) return(list(covariance = NA, weights = k_t)) 
  
  return(list(covariance = numerator / denominator, weights = k_t))
  
}

rho_t = matrix(NA, nrow = nrow(grid), ncol = nrow(grid))
for(i in 1:nrow(grid)){
  for(j in 1:nrow(grid)){
  rho_t[i,j] = kernel_cov_1d(as.numeric(grid[i,]), as.numeric(grid[j, ]),
                             Xpaper, grid, bandwidth, "triangle_kernel")
}}
